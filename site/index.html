<!doctype html>

<title>Bantisocial</title>

<link rel='stylesheet' href='styles.css'>
<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.9.0-alpha2/dist/katex.min.css'>

<body>
  <server-sidebar></server-sidebar>
  <div id='content' class='main'>
    <messages></messages>
    <message-editor></message-editor>
  </div>

  <div class='modal-page-cover' style='display: none'></div>

  <script src='https://cdn.jsdelivr.net/combine/npm/riot@3/riot.min.js,npm/riotcontrol@0.0.3,npm/katex@0.9.0-alpha2,npm/mousetrap@1.6.1/mousetrap.min.js'></script>
  <script src='js/websocket.js'></script>

  <script src='tags.js'></script>

  <script>
    'use strict'

    // Time constants
    const SECOND = 1000
    const MINUTE = 60 * SECOND
    const HOUR   = 60 * MINUTE
    const DAY    = 24 * HOUR

    // Keycode constants
    const KEY_ENTER = 13

    // Utilities
    function post(serverURL, path, dataObj) {
      return fetch('//' + serverURL + '/api/' + path, {
        method: 'post',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(dataObj)
      }).then(res => res.json())
    }

    function get(serverURL, path, query = {}) {
      const esc = encodeURIComponent
      const queryString = Object.keys(query).length > 0
        ? '?' + Object.keys(query)
          .map(k => esc(k) + '=' + esc(query[k]))
          .join('&')
        : ''

      return fetch('//' + serverURL + '/api/' + path + queryString)
        .then(res => res.json())
    }

    function parseHash() {
      const hash = window.location.hash
      let state, serverURL = '', channelName = ''

      for (let c = 0; c < hash.length; c++) {
        const char = hash[c]

        if (!state) {
          // Should start with '#/'
          if (c === 0 && char === '#') {
            continue
          } else if (c === 1 && char === '/') {
            state = 'begin_parse'
            continue
          }

          return null
        } else if (state === 'begin_parse') {
          if (char === '+') {
            state = 'server_url'
            continue
          } else {
            return { path: hash.substr(c).split('/') }
          }
        } else if (state === 'server_url') {
          if (char === '#') {
            state = 'channel_name'
          } else {
            serverURL += char
          }
        } else if (state === 'channel_name') {
          channelName += char
        }
      }

      return { serverURL, channelName }
    }

    // State
    class Store {
      constructor() {
        riot.observable(this)
      }
    }

    RiotControl.addStore(new Store())

    let currentServerURL = null, currentChannelName = null, socket = null

    window.addEventListener('hashchange', evt => {
      evt.preventDefault()

      const hash = parseHash()

      if (hash.serverURL) {
        if (hash.serverURL !== currentServerURL) {
          RiotControl.trigger('switch_server', hash.serverURL)
        }

        if (hash.channelName) {
          if (hash.channelName !== currentChannelName) {
            currentChannelName = hash.channelName
            RiotControl.trigger('switch_channel', hash.channelName)
          }
        } else if (currentChannelName !== null) {
          currentChannelName = null
          RiotControl.trigger('switch_channel', null)
        }
      } else {
        RiotControl.trigger('switch_server', null)
      }
    })

    RiotControl.on('switch_server', url => {
      currentServerURL = url
      localStorage.currentServerURL = url

      if (url === null) {
        return RiotControl.trigger('session_id_update', null)
      }

      const serverSessionIDMap = JSON.parse(localStorage.serverSessionIDMap || '{}')
      const sessionID = serverSessionIDMap[url] || null

      // Defer this a little to allow others to react to the
      // switch_server event.
      setTimeout(() => {
        RiotControl.trigger('session_id_update', sessionID)
      }, 10)
    })

    RiotControl.on('session_id_update', sessionID => {
      const serverSessionIDMap = JSON.parse(localStorage.serverSessionIDMap || '{}')

      // Update localStorage sessionID persistence
      serverSessionIDMap[currentServerURL] = sessionID

      localStorage.serverSessionIDMap = JSON.stringify(serverSessionIDMap)
    })

    // WebSockets
    RiotControl.on('socket_message', ({ evt, serverURL, socket }) => {
      // Reply to the ping event.
      if (evt === 'ping for data') {
        const serverSessionIDMap = JSON.parse(localStorage.serverSessionIDMap || '{}')

        socket.send(JSON.stringify({
          evt: 'pong data',
          data: {
            sessionID: serverSessionIDMap[serverURL]
          }
        }))
      }
    })

    ws.init()

    // Compile Riot tags and mount them to the view
    const tags = riot.mount('*')
    const hash = parseHash()
    const servers = JSON.parse(localStorage.serverSessionIDMap || '{}')

    for (const serverURL of Object.keys(servers)) {
      RiotControl.trigger('add_server', serverURL)
    }

    if (hash.serverURL) {
      currentServerURL = hash.serverURL
      RiotControl.trigger('switch_server', hash.serverURL)

      if (hash.channelName) {
        currentChannelName = hash.channelName
        RiotControl.trigger('switch_channel', hash.channelName)
      }
    } else if (localStorage.currentServerURL && localStorage.currentServerURL != 'null') {
      window.location.hash = '#/+' + localStorage.currentServerURL
    } else {
      window.location.hash = '#/'
    }
  </script>
</body>
